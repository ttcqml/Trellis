# Skill 协作指南

> 如何组合使用多个Skill完成复杂的游戏开发需求

---

## Skill 层次结构

```
┌─────────────────────────────────────────────────────┐
│                   编排层 (Orchestration)              │
│  ┌─────────────────────────────────────────────┐    │
│  │           godot-game-builder                │    │
│  │     理解游戏需求，协调底层Skill执行           │    │
│  └─────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                   执行层 (Execution)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌───────────┐  │
│  │ scene-builder│  │ role-builder │  │event-builder│ │
│  │   场景组装    │  │   角色创建   │  │  事件逻辑  │  │
│  └──────────────┘  └──────────────┘  └───────────┘  │
│                                                     │
│  ┌──────────────────────────────────────────────┐   │
│  │         behavior-tree-builder                │   │
│  │              AI行为树创建                     │   │
│  └──────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                   工具层 (Tools)                     │
│              MCP Tools (Godot Editor RPC)           │
│  OpenScene, InstantiateScene, AddBehavior, etc.    │
└─────────────────────────────────────────────────────┘
```

---

## Skill 职责划分

| Skill | 层次 | 输入 | 输出 | 职责边界 |
|-------|------|------|------|----------|
| **godot-game-builder** | 编排层 | 游戏需求描述 | 调用其他Skill | 需求分析、任务分解、Skill协调 |
| **godot-scene-builder** | 执行层 | 实体列表、位置 | .tscn场景文件 | 只负责场景结构，不处理逻辑 |
| **godot-role-builder** | 执行层 | 角色属性配置 | .tscn角色文件 | 只负责单个角色，不处理场景 |
| **godot-event-builder** | 执行层 | 事件/条件/动作 | FlowKit事件表 | 只负责事件逻辑，不创建实体 |
| **godot-behavior-tree-builder** | 执行层 | AI行为描述 | .tscn行为树文件 | 只负责行为树，不处理其他逻辑 |

---

## 常见组合模式

### 模式1: 简单游戏场景
**需求特征**: 使用预制角色，只需组装和添加逻辑

```
godot-game-builder
       │
       ├──► godot-scene-builder (组装场景)
       │
       └──► godot-event-builder (添加逻辑)
```

**示例**: "创建一个有玩家和3个怪物的测试场景"

### 模式2: 自定义角色场景
**需求特征**: 角色需要自定义属性（血量、速度等）

```
godot-game-builder
       │
       ├──► godot-role-builder (创建自定义角色)
       │
       ├──► godot-scene-builder (组装场景，使用自定义角色)
       │
       └──► godot-event-builder (添加逻辑)
```

**示例**: "创建一个Boss战场景，Boss血量500，速度50"

### 模式3: 自定义AI场景
**需求特征**: 需要特殊的AI行为逻辑

```
godot-game-builder
       │
       ├──► godot-behavior-tree-builder (创建行为树)
       │
       ├──► godot-role-builder (创建角色，关联行为树)
       │
       ├──► godot-scene-builder (组装场景)
       │
       └──► godot-event-builder (添加逻辑)
```

**示例**: "创建一个巡逻敌人，发现玩家后追击并攻击"

### 模式4: 纯角色创建
**需求特征**: 只创建角色，不涉及场景

```
godot-role-builder (直接调用)
```

**示例**: "创建一个史莱姆敌人，血量50，速度80"

### 模式5: 纯逻辑添加
**需求特征**: 场景已存在，只需添加逻辑

```
godot-event-builder (直接调用)
```

**示例**: "为现有场景添加：玩家死亡时重新加载场景"

---

## 调用顺序规则

### 依赖关系
```
行为树 ──► 角色 ──► 场景 ──► 事件逻辑
  │         │        │         │
  │         │        │         └─ 依赖场景中的节点名
  │         │        └─ 依赖角色场景路径
  │         └─ 依赖行为树路径（可选）
  └─ 无依赖
```

### 正确的调用顺序
1. **先创建行为树**（如果需要自定义AI）
2. **再创建角色**（如果需要自定义属性）
3. **然后创建场景**（组装所有实体）
4. **最后添加事件逻辑**（引用场景中的节点）

### 错误示例
```
❌ 先创建场景，再创建角色
   → 场景无法引用尚未存在的角色

❌ 先添加事件逻辑，再创建场景
   → 事件引用的节点不存在

❌ 先创建角色，再创建行为树
   → 角色无法关联尚未存在的行为树
```

---

## 数据传递约定

### 路径传递
当Skill创建了新文件后，需要记录路径供后续Skill使用：

| 创建Skill | 输出路径格式 | 使用Skill |
|-----------|--------------|-----------|
| role-builder | `res://RequirementImp/[Type]/[Name].tscn` | scene-builder |
| behavior-tree-builder | `res://RequirementImp/BehaviorTree/[Name].tscn` | role-builder |
| scene-builder | `res://RequirementImp/Scenes/[Name].tscn` | event-builder |

### 节点名传递
场景中的节点名需要在事件逻辑中引用：

```python
# scene-builder 输出
entities = [
    {"name": "Player", "scene": "...", "position": {...}},
    {"name": "Monster1", "scene": "...", "position": {...}},
]

# event-builder 输入（引用上面的节点名）
events = [
    {
        "event": "on_ready",
        "target": "System",
        "actions": [
            {"action": "set_node_enabled", "target": "Monster1", "inputs": {...}}
        ]
    }
]
```

---

## 需求分析模板

当收到游戏需求时，按以下模板分析：

```markdown
## 1. 实体分析
- [ ] 需要哪些实体？（玩家、敌人、道具、地图等）
- [ ] 哪些实体需要自定义属性？
- [ ] 哪些实体需要自定义AI？

## 2. 逻辑分析
- [ ] 有哪些触发条件？（碰撞、信号、时间等）
- [ ] 触发后执行什么动作？
- [ ] 需要哪些状态变量？

## 3. Skill调用计划
1. [ ] godot-behavior-tree-builder: ___
2. [ ] godot-role-builder: ___
3. [ ] godot-scene-builder: ___
4. [ ] godot-event-builder: ___

## 4. 资源清单
- 场景路径: ___
- 角色路径: ___
- 行为树路径: ___
```

---

## 最佳实践

### 1. 先分析后执行
在调用任何Skill之前，先完成需求分析，确定完整的调用计划。

### 2. 使用预制资源
优先使用预制模板，只在必要时创建自定义资源：
- 普通玩家 → `FCharacterTest.tscn`
- 普通怪物 → `FMonsterTest.tscn`
- 普通行为 → `MonsterAttackTree.tscn`

### 3. 命名一致性
确保在所有Skill调用中使用一致的命名：
```
角色名: "Slime"
  → 角色路径: res://RequirementImp/Monster/Slime.tscn
  → 场景中节点名: "Slime"
  → 事件中引用: target_node = "Slime"
```

### 4. 增量构建
对于复杂场景，可以分步构建：
1. 先创建最小可运行版本
2. 验证基础功能
3. 逐步添加更多实体和逻辑

### 5. 验证每一步
每个Skill执行后，在Godot编辑器中验证结果，再继续下一步。

---

## 常见问题

### Q: 如何判断是否需要自定义角色？
**A**: 检查用户需求中是否提到具体数值（血量、速度、攻击力等）或特殊能力。如果只是"玩家"、"怪物"这样的泛指，使用预制模板即可。

### Q: 事件逻辑中的信号从哪里来？
**A**: 信号需要在代码或其他事件中触发。常见模式：
- 敌人死亡时发送"敌人死亡"信号
- 道具被拾取时发送"道具收集"信号
- 使用全局变量计数，满足条件时发送信号

### Q: 多个场景如何共享角色？
**A**: 角色场景创建一次后，可以在多个游戏场景中实例化。将角色场景保存到 `res://RequirementImp/[Type]/` 目录，然后在各个场景中引用。
